// ---------------------------------------------------------------------------
// üçÉ JetLeaf Framework - https://jetleaf.hapnium.com
//
// Copyright ¬© 2025 Hapnium & JetLeaf Contributors. All rights reserved.
//
// This source file is part of the JetLeaf Framework and is protected
// under copyright law. You may not copy, modify, or distribute this file
// except in compliance with the JetLeaf license.
//
// For licensing terms, see the LICENSE file in the root of this project.
// ---------------------------------------------------------------------------
// 
// üîß Powered by Hapnium ‚Äî the Dart backend engine üçÉ

import 'package:jetleaf_lang/lang.dart';

import 'path_segment.dart';

/// {@template path_pattern}
/// Represents a compiled path pattern in JetLeaf that can be efficiently
/// matched against incoming request paths.
///
/// A [PathPattern] is composed of multiple [PathSegment] instances
/// (literal, variable, wildcard, or regex segments) and includes metadata
/// about its matching behavior, specificity, and optional features such
/// as case-insensitivity or trailing slashes.
///
/// ### Example
/// ```dart
/// final pattern = PathPattern(
///   pattern: '/api/users/{id}',
///   segments: [
///     LiteralSegment('api'),
///     LiteralSegment('users'),
///     VariableSegment('id'),
///   ],
///   hasWildcard: false,
///   hasVariables: true,
///   optionalTrailingSlash: true,
///   caseInsensitive: true,
///   isStatic: false,
///   matchingRank: 10,
/// );
///
/// final variableNames = pattern.getVariableNames(); // { 'id' }
/// final specificity = pattern.getSpecificityScore(); // 10100
/// ```
///
/// ### Usage in JetLeaf
/// [PathPattern] is typically generated by a route parser and used
/// by the JetLeaf router to efficiently match requests, extract path
/// variables, and determine priority between overlapping routes.
///
/// ### See also
/// - [PathSegment] ‚Äî individual components of a path.
/// - [LiteralSegment], [VariableSegment], [WildcardSegment], [RegexSegment] ‚Äî segment types.
/// {@endtemplate}
class PathPattern with EqualsAndHashCode {
  /// The original path pattern string, as defined in the route.
  final String pattern;

  /// Parsed list of [PathSegment] instances derived from [pattern].
  final List<PathSegment> segments;

  /// `true` if the pattern contains any wildcard segments (`*` or `**`).
  final bool hasWildcard;

  /// `true` if the pattern contains any variable segments (`{name}`).
  final bool hasVariables;

  /// `true` if the trailing slash is optional during matching.
  final bool optionalTrailingSlash;

  /// `true` if path matching should ignore case.
  final bool caseInsensitive;

  /// `true` if this pattern contains no variables or wildcards (fully static).
  final bool isStatic;

  /// Rank used to resolve conflicts when multiple patterns match the same path.
  /// Lower values indicate higher priority.
  final int matchingRank;

  /// Creates a new compiled [PathPattern] with all segments and metadata.
  ///
  /// All properties are required to fully define the behavior of the pattern.
  /// 
  /// {@macro path_pattern}
  PathPattern({
    required this.pattern,
    required this.segments,
    required this.hasWildcard,
    required this.hasVariables,
    required this.optionalTrailingSlash,
    required this.caseInsensitive,
    required this.isStatic,
    required this.matchingRank,
  });

  /// Returns the set of variable names defined in this pattern.
  ///
  /// Iterates through all segments and collects the names of [VariableSegment]s.
  ///
  /// ### Example
  /// ```dart
  /// final pattern = PathPattern(...);
  /// final vars = pattern.getVariableNames(); // e.g., { 'id', 'userId' }
  /// ```
  Set<String> getVariableNames() {
    final names = <String>{};

    for (final segment in segments) {
      if (segment is VariableSegment) {
        names.add(segment.name);
      }
    }

    return names;
  }

  /// Computes a specificity score for this pattern.
  ///
  /// The score is used for ranking overlapping patterns when matching paths.
  /// Higher scores indicate more specific patterns:
  /// - `LiteralSegment` contributes 10,000 points.
  /// - `VariableSegment` contributes 100 points.
  /// - `WildcardSegment` contributes 50 for single-segment `*` or 1 for multi-segment `**`.
  int getSpecificityScore() {
    int score = 0;

    for (final segment in segments) {
      if (segment is LiteralSegment) {
        score += 10000;
      } else if (segment is VariableSegment) {
        score += 100;
      } else if (segment is WildcardSegment) {
        score += (segment.multiSegment ? 1 : 50);
      }
    }

    return score;
  }

  @override
  String toString() => 'PathPattern($pattern)';

  @override
  List<Object?> equalizedProperties() => [runtimeType, pattern];
}